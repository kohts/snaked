#!/usr/bin/perl
#
#   snaked: cool cron replacement.
#
#
#   petya@kohts.ru
#
#

BEGIN {
  # unbuffered output
  $| = 1;

  use Cwd;
  use FindBin;

  # without this chroot abs_path (below)
  # returns empty string if daemon is called
  # from some shell script and current directory
  # is a home directory of a user (permissions?)
  chroot('/');

  $ENV{'MY_BIN'} = "$FindBin::Bin";
  $ENV{'MY_LIB'} = Cwd::abs_path("$ENV{'MY_BIN'}/../lib");
  if (! -d $ENV{'MY_LIB'}) {
    $ENV{'MY_LIB'} = Cwd::abs_path("$ENV{'MY_BIN'}/lib");
  }

  $ENV{'MY_ETC'} = "/etc/snaked";
  $ENV{'MY_ROOT'} = Cwd::abs_path("$ENV{'MY_BIN'}/../../../..");

  if (!$ENV{'PS_SNAKED_LIB'}) {
    $ENV{'PS_SNAKED_LIB'} = $ENV{'MY_LIB'};
  }
};

use strict;
use warnings;

use lib "$ENV{'MY_LIB'}";
use lib "$ENV{'PS_SNAKED_LIB'}";
use snaked;
use Yandex::Tools;
use Yandex::Tools::ProcessList;

package snaked::Daemon;
use Storable;
use Time::HiRes qw/usleep/;
use Schedule::Cron::Events;
use Time::Local;
use POSIX;
use IO::Handle; # autoflush
use Socket; # socketpair
use Fcntl;

my $version = '($Id: snaked 4832 2011-01-17 12:19:37Z kohts $)';

my ($daemon_regexp_configured, $daemon_match_cfg, $daemon_match_cfg1, $daemon_match_nocfg, $watchdog_match, $watchdog_match1);

my $my_path;
my $my_command_line;
my $watchdogs2maintain = 1;

sub watchdog_check_timeout {
  my ($opts) = @_;
  
  my $average_number_of_processes = 50 * 2; # 50 is average

  $opts = {} unless $opts;
  $opts->{'watchdogs2maintain'} = 0
    unless $watchdogs2maintain;
  $opts->{'number_of_processes'} = $average_number_of_processes
    unless $opts->{'number_of_processes'};

  my $timeout_step = ($opts->{'watchdogs2maintain'} + 1) * 2 * 2000000; # 8 secs

  my $k =
    int($opts->{'number_of_processes'} / $average_number_of_processes) *
    2 *
    $opts->{'watchdogs2maintain'} *
    1000000; # microseconds

  return $timeout_step + $k;
}

$snaked::Daemon::runtime = {
  "type" => "master",

  "flags" => {
    "stop" => 0,
    "refresh_configuration" => 0,
    },

  "children" => {},

  "usec_2check_watchdog" => 0,
  "usec_2refresh_configuration" => 0,
  
  "start_time" => time(),

  "tasks" => {}, # mixed configuration and runtime task options/parameters

  "config" => {},

  };

sub sigTERM_handler {
#  Yandex::Tools::do_log("snaked $$ term");
  if ($snaked::Daemon::runtime->{'type'} eq 'master') {
    $snaked::Daemon::runtime->{'flags'}->{'stop'} = 1;
  }
  elsif ($snaked::Daemon::runtime->{'type'} eq 'watchdog') {
    exit;
  }
}
sub sigHUP_handler {
  if ($snaked::Daemon::runtime->{'type'} eq 'master') {
    $snaked::Daemon::runtime->{'flags'}->{'refresh_configuration'} = 1;
  }
}
sub sigUSR1_handler {
}
sub sigUSR2_handler {
  if ($snaked::Daemon::runtime->{'type'} eq 'master') {
    # do not restart if alreadying being stopped
    if (!$snaked::Daemon::runtime->{'flags'}->{'stop'}) {
      $snaked::Daemon::runtime->{'flags'}->{'restart'} = 1;
    }
  }
}

#Yandex::Tools::disable_all_signals();

$SIG{'TERM'} = \&sigTERM_handler;
$SIG{'HUP'} = \&sigHUP_handler;
$SIG{'USR1'} = \&sigUSR1_handler;
$SIG{'USR2'} = \&sigUSR2_handler;

sub help() {
  print '
    snaked -- cron as it should be
    ' . $version . '

    command-line options:
      
      start-up type:
        --daemon    -- run in background
        --debug     -- run in foreground with debug output

      runtime control:
        --restart [--wait] -- schedule restart for currently running daemon
                              (valid only for backgrounded daemon)
        --configure        -- schedule reread of configuration
        --status           -- is there daemon running?
        --stop [--wait]    -- schedule stop for currently running daemon

      configuration:
        --show-jobs   -- show configured daemon jobs
        --version     -- show daemon version

';
  exit 0;
}

sub config_value {
  my ($option_name) = @_;

  my $config = $snaked::Daemon::runtime->{'config'};
  if ($config->{$option_name}) {
    return $config->{$option_name}->{'value'};
  }
  
  return undef;
}

sub do_err_log {
  my ($msg) = @_;

  my $config = $snaked::Daemon::runtime->{'config'};

  if (config_value('log_errors')) {
    my $tmp_log = Yandex::Tools::get_log_filename();
    Yandex::Tools::set_log_filename(config_value('log_errors'));
    
    # just in case it fails
    my $res = eval {
      Yandex::Tools::do_log($msg);
    };

    Yandex::Tools::set_log_filename($tmp_log);
  }
}

sub run_task {
  my ($task_name) = @_;
  
  my $config = $snaked::Daemon::runtime->{'config'};
  my $task = $snaked::Daemon::runtime->{'tasks'}->{$task_name};

  my $old_job_name;
  $old_job_name = $ENV{'JOB_NAME'} if defined($ENV{'JOB_NAME'});
  $ENV{'JOB_NAME'} = $task_name;

  my $start_time = time();
 
  Yandex::Tools::debug("running task [$task_name] timeout [$task->{'execution_timeout'}] kill timeout [$task->{'kill_timeout'}]");
  my $o = Yandex::Tools::run_forked($task->{'cmd'}, {
    'timeout' => $task->{'execution_timeout'},
    'terminate_on_parent_sudden_death' => 1,
    'terminate_on_signal' => 'TERM',
    'terminate_wait_time' => $task->{'kill_timeout'},
    'clean_up_children' => 1,
    });
  Yandex::Tools::debug("finished [$task_name]: " . Yandex::Tools::safe_string($o->{'exit_code'}));

  $ENV{'JOB_NAME'} = $old_job_name if $old_job_name;

  if ($o->{'parent_died'}) {
    do_err_log("[$$] my parent died, exiting");
    Yandex::Tools::do_log("[$$] my parent died, exiting");
    exit 1;
  }
  elsif ($o->{'err_msg'}) {
    if (! defined($task->{'disable_notifications'})) {
      # save first failure time (this is only valid during
      # child life, parent will set this again in its
      # memory space after child returns $o->{'err_msg'})
      $task->{'runtime'}->{'first_failure_time'} = time()
        unless $task->{'runtime'}->{'first_failure_time'};

      my $end_time = time();

      my $task_info =
        "\n\n" .
        "task summary\n" .
        "------------\n" .
        "pid: $$\n" .
        "cmdline: $task->{'cmd'}\n" .
        "start time: $start_time (" . localtime($start_time) . ")\n" .
        "end time: $end_time (" . localtime($end_time) . ")\n"
        ;

      # do not notify more often than once
      # each $task->{'notification_interval'} seconds
      # (notify after each failure if not defined)
      if ($task->{'notification_interval'}) {
        if ($task->{'runtime'}->{'first_failure_time'} + $task->{'notification_interval'} < time()) {
          Yandex::Tools::send_mail({
            'to' => ($task->{'admin_email'} ? $task->{'admin_email'} : $config->{'admin_email'}->{'value'}),
            'subject' => $0 . ": $task_name warning",
            'body' => $o->{'err_msg'} . $task_info,
            'no_cc_all' => 1,
            });
          
          # pretend that everything went fine
          # (this will make parent reset first_failure_time)
          return "";
        }
      }
      else {
        Yandex::Tools::send_mail({
          'to' => ($task->{'admin_email'} ? $task->{'admin_email'} : $config->{'admin_email'}->{'value'}),
          'subject' => $0 . ": $task_name warning",
          'body' => $o->{'err_msg'} . $task_info,
          'no_cc_all' => 1,
          });
      
        # if we have no notification interval
        # do not mask errors from parent --
        # so it can log them (!)
        #
      }
    }

    # if notification was not sent --
    # let parent know that we had problem
    # and it should set first_failure_time
    # (if not set)
    return $o->{'err_msg'};
  }

  return "";
}

sub add_child {
  my ($task_name, $opts) = @_;

  $opts = {} unless $opts;

  Yandex::Tools::die ("Programmer error: add_child expects at least child name")
    unless $task_name;

  my $child_socket;
  my $parent_socket;

  socketpair($child_socket, $parent_socket, AF_UNIX, SOCK_STREAM, PF_UNSPEC) ||
    Yandex::Tools::die ("socketpair: $!");

  $child_socket->autoflush(1);
  $parent_socket->autoflush(1);

  my $pid;

  if ($pid = fork) {
    # we are a parent
    close $parent_socket;

    my $flags = 0;
    fcntl($child_socket, F_GETFL, $flags) || die "can't fnctl F_GETFL: $!";
    $flags |= O_NONBLOCK;
    fcntl($child_socket, F_SETFL, $flags) || die "can't fnctl F_SETFL: $!";

    my $child = {
      'pid' => $pid,
      'name' => $task_name,
      'borntime' => time(),
      'killtime' => 0,
      'child_socket' => $child_socket,
      'output' => '',
      };

    $snaked::Daemon::runtime->{'children'}->{'by_pid'}->{$pid} = $child;
    $snaked::Daemon::runtime->{'children'}->{'by_name'}->{$task_name}->{$pid} = $child;

    child_started($task_name);
  }
  else {
    Yandex::Tools::die("cannot fork: $!") unless defined $pid;

    $snaked::Daemon::runtime->{'type'} = "child";
    close $child_socket;

    my $r = run_task($task_name);

    while ($r =~ /([^\r\n]+?)([\r\n]|$)/sg) {
      my $s = $1;
      my $e = $2;

      print $parent_socket "$s\n";
    }

    close($parent_socket);
    exit 0;
  }
}

sub find_child {
  my ($name) = @_;
  if (!$snaked::Daemon::runtime->{'children'}->{'by_name'}->{$name}) {
    return undef;
  }

  # future use: several children for one task (not implemented now)
  return scalar(keys %{$snaked::Daemon::runtime->{'children'}->{'by_name'}->{$name}});
}

sub child_started {
  my ($name) = @_;
  my $task = $snaked::Daemon::runtime->{'tasks'}->{$name};
  $task->{'last_start'} = time();
  if ($task->{'cron'}) {
    $task->{'next_run'} = timelocal($task->{'cron'}->nextEvent);
  }
}

sub child_finished {
  my ($name, $output) = @_;
  my $task = $snaked::Daemon::runtime->{'tasks'}->{$name};
  $task->{'last_finish'} = time();
  if ($output) {
    do_err_log("[$name]: $output");
    Yandex::Tools::do_log("[$name]: $output");
  }
}

# reads output from child if any
# (so it can't overflow IPC buffer)
#
sub manage_child {
  my ($pid) = @_;

  my $child = $snaked::Daemon::runtime->{'children'}->{'by_pid'}->{$pid};

  my $child_socket = $child->{'child_socket'};
  my $child_output = "";
  while (my $l = <$child_socket>) {
    $child_output .= $l;
  }
  
  $child->{'output'} .= $child_output;
}

sub remove_child {
  my ($pid) = @_;

  Yandex::Tools::die("Programmer error: remove_child called on child which hasn't finished yet")
    if waitpid($pid,WNOHANG) ne -1;

  my $child = $snaked::Daemon::runtime->{'children'}->{'by_pid'}->{$pid};
  my $task = $snaked::Daemon::runtime->{'tasks'}->{$child->{'name'}};

  close($child->{'child_socket'});

  # if child has output -- then it had some situation
  # which requires user invervention; save failure time
  #
  # (unset when child returns nothing --
  # meaning intervention is no longer needed)
  #
  if ($child->{'output'}) {
    $task->{'runtime'}->{'first_failure_time'} = time()
      unless $task->{'runtime'}->{'first_failure_time'};

    Yandex::Tools::debug("child output: " . $child->{'output'});

    if (! defined($task->{'disable_notifications'})) {
      # reset failure interval counter,
      # so we do not send notifications
      # more ofthen than notification_interval
      if ($task->{'runtime'}->{'first_failure_time'} + $task->{'notification_interval'} < time()) {
        $task->{'runtime'}->{'first_failure_time'} = time();
      }
    }
  }
  else {
    # delete first error time so next failure time will be saved
    delete($task->{'runtime'}->{'first_failure_time'});
  }

  child_finished($child->{'name'}, $child->{'output'});

  delete $snaked::Daemon::runtime->{'children'}->{'by_name'}->{$child->{'name'}}->{$pid};
  delete $snaked::Daemon::runtime->{'children'}->{'by_pid'}->{$pid};
}

sub have_children {
  my $have_children = 0;
  foreach my $k (keys %{$snaked::Daemon::runtime->{'children'}->{'by_pid'}}) {
    $have_children = 1;
    last;
  }
  return $have_children;
}

sub for_each_child {
  my ($opts) = @_;

  $opts = {} unless $opts;
  foreach my $k (keys %{$snaked::Daemon::runtime->{'children'}->{'by_pid'}}) {
    if ($opts->{'stop_now'}) {
#      Yandex::Tools::do_log("killing $k");
      kill(15, $k); # TERM (default for run_forked)
    }
  }
}

# spawn tasks which should and could be spawned
#
sub run_scheduling {

  # all configured tasks (by name)
  my $tasks = $snaked::Daemon::runtime->{'tasks'};

  # configured tasks which should be run (by name)
  my $should_be_run_tasks = {};

  # configured tasks which should and could be run now (by last_start time)
  my $could_be_run_tasks = {};


  # choose tasks which should be run
  foreach my $task_name (keys %{$tasks}) {
    my $task = $tasks->{$task_name};

    # totally skip disabled tasks
    next if defined($task->{'disabled'});
    
    my $now = time();

    # postpone tasks which have start_random_sleep configured
    #
    if ($task->{'start_random_sleep'} && !$task->{'startup_sleep_finished'}) {
      if (!$task->{'startup_sleep'}) {
        $task->{'startup_sleep'} = int(rand($task->{'start_random_sleep'}));
        $task->{'startup_sleep_started'} = $now;
        Yandex::Tools::debug("task [$task_name] random sleep [$task->{'startup_sleep'}]");
      }

      if ($now - $task->{'startup_sleep_started'} > $task->{'startup_sleep'}) {
        $task->{'startup_sleep_finished'} = $now;
        Yandex::Tools::debug("task [$task_name] random sleep finished");
      }
    }
    else {
      # random startup sleep not configured for the task
      $task->{'startup_sleep_finished'} = $now;
    }

    # skip tasks which are sleeping their random start-up time
    #
    next unless $task->{'startup_sleep_finished'};

    # choose tasks which should be run
    # (for which the time has come)
    #
    # decision about cron tasks can be made
    # just using cron schedule, but for the
    # execution_interval tasks we have to check
    # last_finish/last_start times
    #
    if ($task->{'cron'}) {
      if ($task->{'next_run'} <= $now) {
        $should_be_run_tasks->{$task_name} = $task;
      }
    }
    elsif ($task->{'execution_interval'}) {
      if (!$task->{'last_finish'}) {
        $should_be_run_tasks->{$task_name} = $task;
      }
      elsif ($task->{'last_start'} + $task->{'execution_interval'} <= $now) {
        $should_be_run_tasks->{$task_name} = $task;
      }
    }
    else {
      # configuration validation is done in refreshOptions
    }
  }

  # for each task which should be run check
  #   1) that it's not already running
  #   2) that it's possible to run it (dependencies)
  #
  foreach my $task_name (keys %{$should_be_run_tasks}) {
    my $task = $should_be_run_tasks->{$task_name};

    # skips tasks which are already running
    next if find_child($task_name);
    
    # remove tasks which were marked to be removed
    # when the time comes to execute them knowing
    # that it does not run currently (see above)
    if ($task->{'TO_BE_REMOVED'}) {
      delete $snaked::Daemon::runtime->{'tasks'}->{$task_name};
      next;
    }

    # check that no conflicting tasks are running
    #
    my $conflicting_tasks_are_running;
    CHECK_CONFLICTS: foreach my $ct_name (keys %{$task->{'conflicts_hash'}}) {
      if (find_child($ct_name)) {
        $conflicting_tasks_are_running = 1;
        last CHECK_CONFLICTS;
      }
    }

    next if $conflicting_tasks_are_running;

    my $last_start_label = $task->{'last_start'} || -1;
    
    $could_be_run_tasks->{$last_start_label} = []
      unless $could_be_run_tasks->{$last_start_label};

    push (@{$could_be_run_tasks->{$last_start_label}}, $task_name);
  }

  # choose random task from the tasks
  # with the oldest last_start time
  # (or even no last_start time at all)
  #
  # start it and leave scheduling
  # (so the algorithm is run on the next cycle,
  # accounting for the currently spawned task)
  # 
  START_TASK: foreach my $last_start_label (sort {$a <=> $b} keys %{$could_be_run_tasks}) {
    my $tasks_to_be_started = $could_be_run_tasks->{$last_start_label};
    
    my $total_possible_tasks = scalar(@{$tasks_to_be_started});
    my $random_index = int(rand($total_possible_tasks));

    my $task_name_to_start = ${$tasks_to_be_started}[$random_index];

    Yandex::Tools::debug("starting [$task_name_to_start]");
    add_child($task_name_to_start);

    last START_TASK;
  }
}

sub refreshOptions {
  my ($dir, $opts) = @_;
  
  $opts = {} unless $opts;

  my $config = $snaked::Daemon::runtime->{'config'};
  my $tasks = Storable::dclone($snaked::Daemon::runtime->{'tasks'});
  my $tmp;

  # read daemon options
  my $new_options = {};
  my $old_log_options = Yandex::Tools::get_log_options();

  $tmp = Yandex::Tools::read_dir($dir, {'output_type' => 'arrayref', 'only-files' => 1});
  foreach my $o (@{$tmp}) {
    next if $o =~ /^\./o;

    my $fileinfo = Yandex::Tools::fileinfo_struct({'absolute_name' => $dir . "/" . $o});

    $new_options->{$o} = 1;

    # option was not modified since we've read it
    if ($config->{$o} && $config->{$o}->{'mtime'} eq $fileinfo->{'mtime'}) {
      next;
    }

    my $option_updated = ($config->{$o} ? 1 : 0);

    $config->{$o}->{'mtime'} = $fileinfo->{'mtime'};
    $config->{$o}->{'value'} = Yandex::Tools::read_file_option($dir . "/" . $o);

    if ($option_updated) {
      Yandex::Tools::do_log("new value for option $o: " . $config->{$o}->{'value'});
    }
  }

  # remove old options
  foreach my $opt_name (keys %{$config}) {
    next if $new_options->{$opt_name};
    next if $opt_name eq 'admin_email'; # should list all options which have defaults here
    
    delete ($config->{$opt_name});
    Yandex::Tools::do_log("option $opt_name removed");
  }

  if (!$config->{'admin_email'}) {
    $config->{'admin_email'} = {
      'value' => 'root',
      'mtime' => 0,
      };
  }

  # configure logging (defaults to /tmp/ps-snaked.log, three 10MB files, rotated)
  #
  my $log_options = {};
  if ($config->{'log'}) {
    $log_options->{'filename'} = $config->{'log'}->{'value'};
  }
  else {
    $log_options->{'filename'} = ($ENV{'MY_ROOT'} eq "/" ? "" : $ENV{'MY_ROOT'}) . "/tmp/snaked.log";
  }
  if ($config->{'log_rotate_size'}) {
    $log_options->{'rotate_size'} = $config->{'log_rotate_size'}->{'value'};
  }
  else {
    $log_options->{'rotate_size'} = 1024 * 1024 * 10;
  }
  if ($config->{'log_rotate_keep_copies'}) {
    $log_options->{'rotate_keep_copies'} = $config->{'log_rotate_keep_copies'}->{'value'};
  }
  else {
    $log_options->{'rotate_keep_copies'} = 2;
  }
  Yandex::Tools::set_log_options($log_options);

  if (!Yandex::Tools::get_log_options() || !Yandex::Tools::can_log()) {
    if ($old_log_options) {
      Yandex::Tools::set_log_options($old_log_options);
    }
    else {
      Yandex::Tools::warn("Can not write to log file [$log_options->{'filename'}], check permissions; logging to STDERR");
    }
  }

  # in watchdog mode we don't need
  # to read job definitions
  return if $opts->{'no-jobs'};


  my $defined_jobs = {};

  # read daemon jobs
  if (-d "$dir/jobs") {
    $tmp = Yandex::Tools::read_dir($dir . "/jobs", {'output_type' => 'arrayref', 'only-directories' => 1});
    foreach my $o (@{$tmp}) {
      next if $o =~ /^\./o;

      $defined_jobs->{$o} = 1;

      my $dirinfo = Yandex::Tools::fileinfo_struct({'absolute_name' => $dir . "/jobs/" . $o});

      # job was not modified since we've read it
      if ($tasks->{$o} && $tasks->{$o}->{'mtime'} eq $dirinfo->{'mtime'}) {
        next;
      }

      # save execution schedule so we can decide below
      # whether we need to recalculate next_run time
      #
      if ($tasks->{$o}->{'execution_schedule'}) {
        $tasks->{$o}->{'previous_execution_schedule'} = $tasks->{$o}->{'execution_schedule'};
      }

      if ($tasks->{$o}) {
        Yandex::Tools::do_log("[$$] reread job [$o] from disk");
      }

      $tasks->{$o}->{'mtime'} = $dirinfo->{'mtime'};

      my $had_disabled;
      my $joptions = Yandex::Tools::read_dir($dir . "/jobs/" . $o, {'output_type' => 'arrayref', 'only-files' => 1});
      foreach my $jo (@{$joptions}) {
        if ($jo eq 'conflicts') {
          $tasks->{$o}->{$jo} = Yandex::Tools::read_file_array($dir . "/jobs/" . $o . "/" . $jo);
        }
        elsif ($jo eq 'cmd') {
          $tasks->{$o}->{$jo} = $dir . "/jobs/" . $o . "/" . $jo;
        }
        elsif ($jo eq 'disabled') {
          $had_disabled = 1;
          $tasks->{$o}->{'disabled'} = 1;
        }
        else {
          $tasks->{$o}->{$jo} = Yandex::Tools::read_file_option($dir . "/jobs/" . $o . "/" . $jo);
        }
      }

      if (!$had_disabled && defined($tasks->{$o}->{'disabled'})) {
        delete ($tasks->{$o}->{'disabled'});
      }
    }
    
    # mark removed jobs, validate tasks
    TASKS: foreach my $task_name (keys %{$tasks}) {
      if (!$defined_jobs->{$task_name}) {
        Yandex::Tools::do_log("job [$task_name] removed from configuration");
        $tasks->{$task_name}->{'TO_BE_REMOVED'} = 1;
        next TASKS;
      }

      my $task = $tasks->{$task_name};

      if (!defined($task->{'execution_timeout'}) || !int($task->{'execution_timeout'})) {
        $task->{'execution_timeout'} = 0;
      }
      if (!defined($task->{'kill_timeout'}) ||
        !int($task->{'kill_timeout'}) && $task->{'kill_timeout'} ne 0) {
        $task->{'kill_timeout'} = 60;
      }

      foreach my $mp ("cmd") {
        if (!$task->{$mp}) {
          Yandex::Tools::do_log("skipping job [$task_name]: mandatory parameter [$mp] not specified");
          delete($tasks->{$task_name});
          next TASKS;
        }
      }
      if (! -x $task->{'cmd'}) {
        Yandex::Tools::do_log("skipping job [$task_name]: [$task->{'cmd'}] is not executable");
        delete($tasks->{$task_name});
        next TASKS;
      }

      # one of scheduling methods must be specified
      #
      if ((!$task->{'execution_interval'} && !$task->{'execution_schedule'}) ||
        ($task->{'execution_interval'} && $task->{'execution_schedule'})) {
        
        Yandex::Tools::do_log("skipping job [$task_name]: one and only one of (execution_interval, execution_schedule) must be defined");
        delete($tasks->{$task_name});
        next TASKS;
      }

      if ($task->{'execution_schedule'} &&
        (
          $task->{'previous_execution_schedule'} && $task->{'execution_schedule'} ne $task->{'previous_execution_schedule'} || # runtime
          !$task->{'previous_execution_schedule'} # start-up
        )
        ) {
        my $cron;
        eval {
          $cron = new Schedule::Cron::Events($task->{'execution_schedule'}, Seconds => time());
        };

        if (!$cron) {
          my $msg = $@;
          # leave only first line
          $msg =~ s/[\r\n].+$//sgo;
          # remove filename in which the error was raised
          $msg =~ s/at\ \/.+$//sgo;
          $msg = ": $msg" if $msg;

          Yandex::Tools::do_log("skipping job [$task_name]: invalid execution_schedule $msg");
          delete($tasks->{$task_name});
          next TASKS;
        }
        $task->{'cron'} = $cron;
        $task->{'next_run'} = timelocal($task->{'cron'}->nextEvent);

        # new schedule was applied, do not bother doing it again
        $task->{'previous_execution_schedule'} = $task->{'execution_schedule'};
      }

      foreach my $dp ("execution_interval", "execution_timeout", "notification_interval", "start_random_sleep") {
        if ($task->{$dp} && !Yandex::Tools::is_digital($task->{$dp})) {
          Yandex::Tools::do_log("skipping job [$task_name]: [$dp] must be numeric");
          delete($tasks->{$task_name});
          next TASKS;
        }
      }

      if ($task->{'conflicts'} && ref($task->{'conflicts'}) ne 'ARRAY') {
        Yandex::Tools::do_log("skipping job [$task_name]: [conflicts] must be an array reference");
        delete($tasks->{$task_name});
        next TASKS;
      }
      if ($task->{'conflicts'}) {
        foreach my $c_task (@{$task->{'conflicts'}}) {
          if ($c_task eq $task_name) {
            Yandex::Tools::do_log("skipping job [$task_name]: task conflicts with itself.");
            delete($tasks->{$task_name});
            next TASKS;
          }
        }
      }

      # defaults
      $task->{'notification_interval'} = 0 unless $task->{'notification_interval'};
    }
  }

  # apply new tasks
  $snaked::Daemon::runtime->{'tasks'} = $tasks;

  # rebuild conflicts_hash for each task
  #
  foreach my $tn (keys %{$tasks}) {
    my $t = $tasks->{$tn};
    
    next unless $t->{'conflicts'};

    foreach my $ctn (@{$t->{'conflicts'}}) {
      my $ct = $tasks->{$ctn};

      # silently skip conflicting tasks
      # which are not configured (configuration typo)
      next unless $ct;

      # (possibly) add $t into $ct conflicts
      $ct->{'conflicts_hash'}->{$tn} = $t;

      # (possibly) add $ct into $t conflicts
      $t->{'conflicts_hash'}->{$ctn} = $ct;
    }
  }
}

sub canonical_command_line {
  my ($cmdline, $path) = @_;

  return "" unless $cmdline && $path;

  # suppress space in the end of command on freebsd
  $cmdline =~ s/\ +$//go;

  # replace path to the executable with full path
  #
  # notes:
  #   - regexp is not global so it replaces only 1st occurrence
  #
  #   - .+? is not greedy so it will find the 1st occurrence of
  #   "(ps-)snaked" string which should be the name of executable
  # 
  $cmdline =~ s/.+?(ps-)?snaked(\s+|$)/${path}\/snaked /;
  $cmdline =~ s/\s+$//goi;

  return $cmdline;
}

sub exec_ps_snaked {
  my ($my_command_line, $my_path) = @_;

  # on ws1-569 in snaked.log got:
  #
  # Mon Oct 19 17:59:17 2009 [/place/home/monitor/ps-snake/usr/local/ps-snake/bin/snaked] unable to exec  --cfg /place/home/monitor/ps-snake/etc/ps-farm/options/ps-snaked
  #
  # which effectively means that $my_command_line was empty
  # after calling canonical_command_line() below
  # (" --cfg ..." was appended to it in the next step)
  #
  # so trying to determine my command line if it's empty
  # (also added check on startup that we've got it)
  #

  # as a workaround for empty command line or path (why?)
  # trying to determine them during exit process
  if (!$my_command_line || !$my_path) {
    ($my_path, $my_command_line) = Yandex::Tools::ProcessList::get_my_path_commandline({'processes' =>
      Yandex::Tools::ProcessList::get_process_table()});
  }

  $my_command_line = canonical_command_line($my_command_line, $my_path);

  # append --cfg parameter if it's not specified
  # (codepath is used only during first run
  # when path to configuration was specified
  # by environment variable)
  if ($my_command_line !~ /--cfg $ENV{'PS_SNAKED_CFG'}/) {
    $my_command_line .= " --cfg $ENV{'PS_SNAKED_CFG'}";
  }

  # set environment variable to specify that we want to cleanup
  # already running snaked processes (this might be workaround
  # for some FreeBSD or Proc::ProcessTable on FreeBSD bug,
  # which caused the following:
  #
  # Thu Jun 24 10:29:31 2010 [/opt/home/monitor/ps-snake/usr/local/ps-snake/bin/snaked] clock moved back from Thu Jun 24 10:29:25 2010 to Thu Jun 24 10:29:24 2010, restarting
  # Thu Jun 24 10:29:38 2010 [/opt/home/monitor/ps-snake/usr/local/ps-snake/bin/snaked] [24836] requested to restart
  # Thu Jun 24 10:29:38 2010 [/opt/home/monitor/ps-snake/usr/local/ps-snake/bin/snaked] [24836] stopped
  # Thu Jun 24 10:29:54 2010 [/opt/home/monitor/ps-snake/usr/local/ps-snake/bin/snaked] [WARN] [29246] snaked is already running: /usr/bin/perl /opt/home/monitor/ps-snake/usr/local/ps-snake/bin/snaked --daemon --cfg /opt/home/monitor/ps-snake/etc/ps-farm/options/ps-snaked  [24836]
  #
  # [monitor@orange64 ~]$ uname -a
  # FreeBSD orange64.yandex.ru 7.2-STABLE FreeBSD 7.2-STABLE #0 r199991M: Mon Feb  8 12:50:25 MSK 2010     root@distillatory.yandex.ru:/place/tmp/mk_pkg.wG1LSf1f/obj/place/GIT-repos/FreeBSD-7-r199991/sys/PRODUCTION  amd64
  #
  # Proc::ProcessTable 0.54
  #
  $ENV{'snaked_cleanup_already_running'} = 1;

  Yandex::Tools::exec($my_command_line);
}

# spawn additional watchdogs slowly,
# returns total number of running processes
#
sub manage_watchdogs {
  my $ptable = Yandex::Tools::ProcessList::get_process_table();

  my $number_of_watchdogs = 0;
  # get the ps-snaked daemon process for which the watchdog is running
  my $my_process = undef;

  foreach my $p (@{$ptable}) {
    next unless $p->cmndline;
    next if !Yandex::Tools::matches_with_one_of_regexps($p->cmndline, [$watchdog_match, $watchdog_match1]);

    $number_of_watchdogs = $number_of_watchdogs + 1;
  }

  if ($number_of_watchdogs < $watchdogs2maintain) {
    my $t_cmdline = $my_command_line;
    $t_cmdline = canonical_command_line($t_cmdline, $my_path);
    $t_cmdline =~ s/\-\-daemon/\-\-watchdog/;
    Yandex::Tools::run_forked($t_cmdline);
  }

  return scalar(@{$ptable});
}

sub stop_watchdogs {
  my $ptable = Yandex::Tools::ProcessList::get_process_table();

  # get the ps-snaked daemon process for which the watchdog is running
  my $my_process = undef;
  foreach my $p (@$ptable) {
    next unless $p->cmndline;
    next if !Yandex::Tools::matches_with_one_of_regexps($p->cmndline, [$watchdog_match, $watchdog_match1]);
    
    kill (15, $p->pid);
  }
}

# watchdog mode, starts ps-snaked daemon
# if finds that it's not running
sub run_watchdog {

  # set daemon type to change signal handling slightly
  $snaked::Daemon::runtime->{'type'} = 'watchdog';

  my $unsuccessful_tries = 0;
  my $life_time = 3600 * (rand($watchdogs2maintain) + 1);

  while(1) {
    # stop watchdogs from time to time to toss
    # their pid numbers (which might affect oom killers),
    # but not in case they detect that main process
    # is not running (and waiting a bit to start it)
    # 
    # watchdogs are restarted by main daemon.
    # 
    if ((time() - $snaked::Daemon::runtime->{'start_time'}) > $life_time && !$unsuccessful_tries) {
      exit(0);
    }

    if ($snaked::Daemon::runtime->{'usec_2check_watchdog'} < 1) {
      my $ptable = Yandex::Tools::ProcessList::get_process_table();

      my $currently_running_watchdogs = 0;

      # get the ps-snaked daemon process for which the watchdog is running
      my $my_process = undef;

      foreach my $p (@$ptable) {
        my $p_cmndline;
        my $r = Yandex::Tools::ProcessList::code_may_fail(sub {$p_cmndline = $p->cmndline});

        next unless $p_cmndline;

        if (Yandex::Tools::matches_with_one_of_regexps($p_cmndline, [$watchdog_match, $watchdog_match1])) {
          $currently_running_watchdogs = $currently_running_watchdogs + 1;
        }
        elsif (Yandex::Tools::matches_with_one_of_regexps($p_cmndline, [$daemon_match_cfg, $daemon_match_cfg1])) {
          # at this point any snaked is selected
          # (even that which is starting
          # or running external command)

          my $p_pid;
          my $p_ppid;
          my $p_pgrp;
          $r = Yandex::Tools::ProcessList::code_may_fail(sub {$p_pid = $p->pid});
          $r = Yandex::Tools::ProcessList::code_may_fail(sub {$p_ppid = $p->ppid});
          $r = Yandex::Tools::ProcessList::code_may_fail(sub {$p_pgrp = $p->pgrp});

          next unless $p_pid && $p_ppid && $p_pgrp;

          # real daemon is parented by init and is the process group leader,
          # if its not found -- start it, and it will clean up any
          # stuck child from previous daemon (shouldn't happen because
          # children are strongly attached to the main daemon
          # with use of terminate_on_sudden_parent_death flag of run_forked)
          if ($p_ppid eq 1 && $p_pid eq $p_pgrp) {
            $my_process = $p;
          }
        }
      }

      if ($my_process) {
        $unsuccessful_tries = 0;
      }
      else {
        $unsuccessful_tries = $unsuccessful_tries + 1;
      }

      if ($unsuccessful_tries > 0) {
        if ($unsuccessful_tries < 2) {
          # 4 seconds should be enough to start daemon
          # (if it's not found and began to start -- is restarting),
          # randomize each watchdog so they do not try to start
          # all at the same time
          # 
          sleep(4 + 4 * int(rand($currently_running_watchdogs)));
        }
        else {
          Yandex::Tools::do_log("watchdog [$$]: snaked not found (killed?), respawning");
          # replace --watchdog with --daemon
          my $t_cmdline = $my_command_line;
          $t_cmdline =~ s/\-\-watchdog/\-\-daemon/;

          # try to execute daemon instead of watchdog
          # if fork fails (wouldn't succeed probably,
          # but could we try at least?)
          #
          if (defined(my $pid = fork)) {
            if ($pid) {
              my $waitpid;
              
              # exec_ps_snaked forks before actually execing snaked
              # and parent exits immediately (which makes it
              # totally detached from watchdog)
              #
              while ($waitpid ne -1) {
                $waitpid = waitpid($pid, WNOHANG);
                sleep 1;
              }

              # watchdog to continue
              $unsuccessful_tries = 0;
            }
            else {
              # watchdog to become snaked
              # (detached from parent totally)
              exec_ps_snaked($t_cmdline, $my_path);
            }
          }
          else {
            exec_ps_snaked($t_cmdline, $my_path);
          }
        }
      }

      $snaked::Daemon::runtime->{'usec_2check_watchdog'} = watchdog_check_timeout({
        'watchdogs2maintain' => $watchdogs2maintain,
        'number_of_processes' => scalar(@{$ptable}),
        });
    }

    usleep(50000);
    $snaked::Daemon::runtime->{'usec_2check_watchdog'} = $snaked::Daemon::runtime->{'usec_2check_watchdog'} - 50000;
  }
  exit (255);
}

sub get_cfg_path {
  if (!$ENV{'PS_SNAKED_CFG'}) {
    if (Yandex::Tools::defined_cmdline_param('cfg')) {
      $ENV{'PS_SNAKED_CFG'} = Yandex::Tools::get_cmdline_param('cfg');

      if (! -d "$ENV{'PS_SNAKED_CFG'}") {
        die "Configuration does not exist: $ENV{'PS_SNAKED_CFG'}\n";
      }
    }
    else {
      $ENV{'PS_SNAKED_CFG'} = $ENV{'MY_ETC'};

      if (! -d $ENV{'PS_SNAKED_CFG'}) {
        $ENV{'PS_SNAKED_CFG'} = ($ENV{'MY_ROOT'} eq "/" ? "" : $ENV{'MY_ROOT'}) .
          "/etc/ps-farm/options/ps-snaked";
      }
      if (! -d $ENV{'PS_SNAKED_CFG'} && -d "/etc/ps-farm/options/ps-snaked") {
        $ENV{'PS_SNAKED_CFG'} = "/etc/ps-farm/options/ps-snaked";
      }
    }
  }

  if (! -d "$ENV{'PS_SNAKED_CFG'}") {
    $ENV{'PS_SNAKED_CFG'} = undef;
  }
  else {
    if (!$daemon_regexp_configured) {
      $daemon_match_cfg = qr/^([^\s]+perl[^\s]*[\s]+|)[^\s]+(ps-)?snaked.+(daemon|debug).+cfg.+$ENV{'PS_SNAKED_CFG'}/;
      $daemon_match_cfg1 = qr/^([^\s]+perl[^\s]*[\s]+|)[^\s]+(ps-)?snaked.+cfg.+$ENV{'PS_SNAKED_CFG'}.+(daemon|debug)/;
      $daemon_match_nocfg = qr/^([^\s]+perl[^\s]*[\s]+|)[^\s]+(ps-)?snaked.+(daemon|debug)/;
      $watchdog_match = qr/^([^\s]+perl[^\s]*[\s]+|)[^\s]+(ps-)?snaked.+(watchdog).+cfg.+$ENV{'PS_SNAKED_CFG'}/;
      $watchdog_match1 = qr/^([^\s]+perl[^\s]*[\s]+|)[^\s]+(ps-)?snaked.+cfg.+$ENV{'PS_SNAKED_CFG'}.+(watchdog)/;
      $daemon_regexp_configured = 1;
    }
  }

  return $ENV{'PS_SNAKED_CFG'};
}

Yandex::Tools::read_cmdline();
get_cfg_path();
Yandex::Tools::ProcessList::set_options({
  'daemon_match' => [$daemon_match_cfg, $daemon_match_cfg1],
  'daemon_match_startup' => [$daemon_match_nocfg],
  });

if (Yandex::Tools::defined_cmdline_param('stop')) {
  my $d = Yandex::Tools::ProcessList::get_other_daemon_process();
  if ($d) {
    print "requesting " . $d->pid() . " [" . $d->cmndline . "] to stop\n";
    kill (15, $d->pid);

    if (Yandex::Tools::defined_cmdline_param('wait')) {
      while (Yandex::Tools::ProcessList::get_other_daemon_process({'refresh_startup_processes' => 1})) {
        print ".";
        sleep 1;
      }
      print "\n";
    }
  }
  else {
    print "no snaked daemon found for $ENV{'PS_SNAKED_CFG'}\n";
  }
  exit 0;
}
elsif (Yandex::Tools::defined_cmdline_param('configure')) {
  my $d = Yandex::Tools::ProcessList::get_other_daemon_process();
  if ($d) {
    print "requesting " . $d->pid() . " [" . $d->cmndline . "] to refresh configuration\n";
    kill ("HUP", $d->pid)
  }
  else {
    print "no snaked daemon found for $ENV{'PS_SNAKED_CFG'}\n";
  }
  exit 0;
}
elsif (Yandex::Tools::defined_cmdline_param('restart')) {
  my $d = Yandex::Tools::ProcessList::get_other_daemon_process();
  if ($d) {
    if (!Yandex::Tools::defined_cmdline_param('only-errors')) {
      print "requesting " . $d->pid() . " [" . $d->cmndline . "] to restart\n";
    }
    kill ("USR2", $d->pid);

    if (Yandex::Tools::defined_cmdline_param('wait')) {
      my $running_daemon = Yandex::Tools::ProcessList::get_other_daemon_process({'refresh_startup_processes' => 1});

      my $no_daemon_retries = 0;
      my $new_daemon_retries = 3;
      my $new_daemon_pid;

      while (!$new_daemon_pid # while previous daemon shuts down and new starts up
          ||
        $new_daemon_pid && # some new daemon started
        $new_daemon_retries > 0 # check that new
        ) {

        $running_daemon = Yandex::Tools::ProcessList::get_other_daemon_process({'refresh_startup_processes' => 1});

        if (!$running_daemon) {
          $no_daemon_retries = $no_daemon_retries + 1;
        }
        else {
          $no_daemon_retries = 0;
        }
        if ($no_daemon_retries > 5) {
          print "snaked won't start, still trying...";
          $no_daemon_retries = 0;
        }

        if ($new_daemon_pid) {
          if ($new_daemon_pid eq $running_daemon->pid) {
            $new_daemon_retries = $new_daemon_retries - 1;
          }
          else {
            $new_daemon_pid = $running_daemon->pid;
            $new_daemon_retries = 3;
          }
        }
        if (!$new_daemon_pid && $running_daemon && $d->pid ne $running_daemon->pid) {
          $new_daemon_pid = $running_daemon->pid;
        }

        print ".";
        sleep 1;
      }
      print "\n";
      print "snaked is running as pid " . $running_daemon->pid . ". command line [" . $running_daemon->cmndline . "]\n";
    }
  }
  else {
    print "no snaked daemon found for $ENV{'PS_SNAKED_CFG'}\n";
  }
  exit 0;
}
elsif (Yandex::Tools::defined_cmdline_param('status')) {
  my $d = Yandex::Tools::ProcessList::get_other_daemon_process();
  if ($d) {
    print "snaked is running as pid " . $d->pid . ". command line [" . $d->cmndline . "]\n";
  }
  else {
    print "no daemon running\n";
  }
  exit 0;
}
elsif (Yandex::Tools::defined_cmdline_param('show-jobs')) {
  refreshOptions($ENV{'PS_SNAKED_CFG'});
  print "    global options\n";
  foreach my $k (sort keys %{$snaked::Daemon::runtime->{'config'}}) {
    print "      $k: " . $snaked::Daemon::runtime->{'config'}->{$k}->{'value'} . "\n";
  }

  print "    configured jobs:\n";
  foreach my $job_name (sort keys %{$snaked::Daemon::runtime->{'tasks'}}) {
    print "      " . $job_name . "\n";
    my $job = $snaked::Daemon::runtime->{'tasks'}->{$job_name};
    foreach my $o (sort keys %{$job}) {
      print "        $o: ";
      if (ref($job->{$o}) eq 'ARRAY') {
        print join(",", @{$job->{$o}});
      }
      else {
        print $job->{$o};
      }
      print "\n";
    }
  }
  exit 0;
}
elsif (Yandex::Tools::defined_cmdline_param('version')) {
  print "$version\n";
  exit 0;
}

my $i_am_watchdog = Yandex::Tools::defined_cmdline_param('watchdog');

if (!Yandex::Tools::defined_cmdline_param('daemon') && !Yandex::Tools::defined_cmdline_param('debug') && !$i_am_watchdog) {
  help();
  exit 0;
}

if (!get_cfg_path()) {
  die "no configuration found (try creating /etc/snaked)";
}
refreshOptions($ENV{'PS_SNAKED_CFG'}, {'no-jobs' => $i_am_watchdog});
if (config_value('log_errors')) {
  if (!Yandex::Tools::can_write(config_value('log_errors'))) {
    Yandex::Tools::warn("Can not write to log_errors file [" . config_value('log_errors') .
      "], check permissions.");
    delete($snaked::Daemon::runtime->{'config'}->{'log_errors'});
  }
}

if (!$i_am_watchdog) {
  my $d = Yandex::Tools::ProcessList::get_other_daemon_process();
  if ($d) {
    if (!$ENV{'snaked_cleanup_already_running'}) {
      Yandex::Tools::warn("[$$] snaked is already running: " . $d->cmndline . " ["  . $d->pid . "]");
      exit 1;
    }
    else {
      my $previous_snaked = $d;
      $ENV{'snaked_cleanup_already_running'} = undef;
      kill(-9, $d->pid);
      sleep 3;
      $d = Yandex::Tools::ProcessList::get_other_daemon_process({'refresh_startup_processes' => 1});
      if ($d) {
        Yandex::Tools::warn("[$$] snaked is already running: " . $d->cmndline . " ["  . $d->pid . "] and doesn't stop on KILL signal");
        exit 1;
      }
      else {
        Yandex::Tools::warn("[$$] killed previously running snaked: " . $previous_snaked->cmndline . " ["  . $previous_snaked->pid . "], continuing to start");
      }
    }
  }
}

($my_path, $my_command_line) = Yandex::Tools::ProcessList::get_my_path_commandline();

Yandex::Tools::debug("my_path: $my_path");
Yandex::Tools::debug("my_command_line: $my_command_line");

print "starting snaked daemon for $ENV{'PS_SNAKED_CFG'}\n"
  unless $i_am_watchdog;

if (Yandex::Tools::defined_cmdline_param('daemon') || $i_am_watchdog) {
  # restart daemon using its full pathname and config path
  # if it was not started like this (so we could distinguish
  # between daemons by their locations)
  if ($my_command_line !~ /$my_path/ || $my_command_line !~ /--cfg $ENV{'PS_SNAKED_CFG'}/) {
    sigUSR2_handler();
  }

  Yandex::Tools::daemonize();

  # run watchdog (except for when snaked
  # would be restarted right after start)
  if ($i_am_watchdog && !$snaked::Daemon::runtime->{'flags'}->{'restart'}) {
    run_watchdog();
    exit;
  }
}
elsif ($Yandex::Tools::debug) {
  # stay in foreground
}

Yandex::Tools::do_log("[$$] started");

if ($snaked::Daemon::runtime->{'config'}->{'pidfile'} &&
  !$snaked::Daemon::runtime->{'flags'}->{'restart'} &&
  !$i_am_watchdog) {

  if (Yandex::Tools::can_write($snaked::Daemon::runtime->{'config'}->{'pidfile'}->{'value'})) {
    Yandex::Tools::write_file_option($snaked::Daemon::runtime->{'config'}->{'pidfile'}->{'value'}, $$);
  }
}

my $previous_now;
my $current_now;

my $max_job_time = config_value('max_job_time');
$max_job_time = 3600 * 2 unless $max_job_time;

while (1) {
  $previous_now = $current_now;
  $current_now = time();

  # clock moved back -- restarting
  if ($previous_now && $current_now && ($previous_now > $current_now)) {
    Yandex::Tools::do_log("clock moved back from " . localtime($previous_now) . " to " . localtime($current_now) . ", restarting");
    sigUSR2_handler();
  }

  if (!$snaked::Daemon::runtime->{'flags'}->{'restart'}) {
    if ($snaked::Daemon::runtime->{'usec_2check_watchdog'} < 1) {
      my $total_number_of_processes = 0;
      if ($watchdogs2maintain) {
        $total_number_of_processes = manage_watchdogs();
      }
      $snaked::Daemon::runtime->{'usec_2check_watchdog'} =
        watchdog_check_timeout({
          'watchdogs2maintain' => $watchdogs2maintain,
          'number_of_processes' => $total_number_of_processes,
          });
    }
  }

  my $have_active_children = values %{$snaked::Daemon::runtime->{'children'}->{'by_pid'}};
  Yandex::Tools::debug("active children:") if $have_active_children;

  # check status of all children removing those which finished
  foreach my $v (values %{$snaked::Daemon::runtime->{'children'}->{'by_pid'}}) {
    
    # minimize time() call a bit
    my $now = time();

    # check for really long running processes
    # and kill them brutally (not very fast
    # if killing doesn't work; blocking io?)
    #
    if (($now - $v->{'borntime'}) > $max_job_time && ($now - $v->{'killtime'}) > 5) {
      # kill first then log, because logging might fail
      # which leads to "die"

      # killing exactly child pid, which is only a "manager"
      # for the task; open3_run which is executed inside the child
      # checks whether manager is alive and terminates if not,
      # so killing manager notifies child that it should stop.
      kill(9, $v->{'pid'});
      $v->{'killtime'} = time();

      do_err_log("killed long running (". ($now - $v->{'borntime'}) .
        " seconds) process [$v->{'pid'}] [$v->{'name'}]", {"stderr" => 1});
      Yandex::Tools::do_log("killed long running (". ($now - $v->{'borntime'}) .
        " seconds) process [$v->{'pid'}] [$v->{'name'}]", {"stderr" => 1});
    }

    my $waitpid = waitpid($v->{'pid'}, WNOHANG);
    
    Yandex::Tools::debug("\tchild [$v->{'pid'}] [$v->{'name'}] [" . ($v->{'id'} ? $v->{'id'} : "") . "]: $waitpid;".
      " running " . (time() - $v->{'borntime'}) . " seconds");

    manage_child($v->{'pid'});

    if ($waitpid eq -1) {
      remove_child($v->{'pid'});
    }
  }

  if ($snaked::Daemon::runtime->{'flags'}->{'refresh_configuration'} ||
    $snaked::Daemon::runtime->{'usec_2refresh_configuration'} < 1) {
    if ($snaked::Daemon::runtime->{'flags'}->{'refresh_configuration'}) {
      Yandex::Tools::do_log("requested to reread configuration, rereading");
    }
    refreshOptions($ENV{'PS_SNAKED_CFG'});
    $snaked::Daemon::runtime->{'flags'}->{'refresh_configuration'} = 0;
    $snaked::Daemon::runtime->{'usec_2refresh_configuration'} = 1000000 * 60;
  }
  if ($snaked::Daemon::runtime->{'flags'}->{'restart'}) {
    if ($Yandex::Tools::debug) {
      Yandex::Tools::warn("unable to restart attached daemon");
      $snaked::Daemon::runtime->{'flags'}->{'restart'} = 0;
    }
    else {
      if (!$snaked::Daemon::runtime->{'flags'}->{'stop'}) {
        Yandex::Tools::do_log("[$$] requested to restart");
        $snaked::Daemon::runtime->{'flags'}->{'stop'} = 1;
      }
    }
  }

  # do processing if we were not requested to stop
  unless ($snaked::Daemon::runtime->{'flags'}->{'stop'}) {
    run_scheduling();
  }
  else {
    # wait for children to exit and exit then
    if (have_children()) {
      for_each_child ({'stop_now' => 1});
      Yandex::Tools::debug("waiting for children to exit");
      sleep 1;
    }
    else {
      unlink($snaked::Daemon::runtime->{'config'}->{'pidfile'}->{'value'})
        if $snaked::Daemon::runtime->{'config'}->{'pidfile'};
      
      Yandex::Tools::do_log("[$$] stopped");

      # do not restart watchdogs on restart as they will try
      # to start snaked if restart fails (which should not happen
      # but happens in 0,02-0,03 % of cases)
      #
      # we may want to send some signal to watchdogs here
      # to notify them about restart so they could extend
      # their waiting cycle a bit
      #
      if ($snaked::Daemon::runtime->{'flags'}->{'restart'}) {
        exec_ps_snaked($my_command_line, $my_path);
      }
      else {
        stop_watchdogs() if !$i_am_watchdog;
      }
      
      exit 0;
    }
  }

  my $usec_to_sleep;
  if ($Yandex::Tools::debug) {
    Yandex::Tools::debug("-");
    $usec_to_sleep = 1000000;
  }
  else {
    if ($have_active_children) {
      $usec_to_sleep = 500000;
    }
    else {
      $usec_to_sleep = 500000;
    }
  }

  usleep($usec_to_sleep);
  $snaked::Daemon::runtime->{'usec_2check_watchdog'} = $snaked::Daemon::runtime->{'usec_2check_watchdog'} - $usec_to_sleep;
  $snaked::Daemon::runtime->{'usec_2refresh_configuration'} = $snaked::Daemon::runtime->{'usec_2refresh_configuration'} - $usec_to_sleep;
}

# yes i know this is the way
# to the world of endless may
exit(255);
